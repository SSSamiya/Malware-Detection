import struct
import pefile
import sys
import base64
import hashlib
import os
from binascii import hexlify
#from Crypto.Protocol.KDF import PBKDF2
from backports.pbkdf2 import pbkdf2_hmac
from malduck import aes, unpad

# FILE_PATH = "C:\\Users\\sarfr\\Desktop\\AsyncRAT\\sample.exe"
FILE_PATH = sys.argv[1]

Settings = {
    1 : "Ports",
    2 : "Hosts",
    3 : "Version", 
    4 : "Install",
    5 : "Install Folder",
    6 : "Install File",
    7 : "Key",
    8 : "Mutex",
    9 : "Certificate",
    10 : "Server Signature"
}

if __name__ == "__main__":
    try:
        encrypted_data = []
        data = open(FILE_PATH, 'rb').read()
        peobject = pefile.PE(data = data)
        entry_point = peobject.OPTIONAL_HEADER.AddressOfEntryPoint

        isDotnet = peobject.OPTIONAL_HEADER.DATA_DIRECTORY[14]
        if(isDotnet.Size != 0):
            dotnet_directoryVA = isDotnet.VirtualAddress
            dotnet_directoryFO = peobject.get_offset_from_rva(dotnet_directoryVA)
            metadata_rva = struct.unpack("<I", data[dotnet_directoryFO + 8 : dotnet_directoryFO+12])[0]
            metadata_size = struct.unpack("<I", data[dotnet_directoryFO + 12 : dotnet_directoryFO + 16])[0]

            metadataFO = peobject.get_offset_from_rva(metadata_rva)
            #print(data[metadataFO : metadataFO + 4])

            no_of_stream = struct.unpack("<H", data[metadataFO + 30 : metadataFO + 32])[0]

            read_offset = metadataFO + 32
            for i in range(0, no_of_stream):
                offset, size = struct.unpack_from("<II", data[read_offset:read_offset+8])
                index = data[read_offset+8:].find(b"\x00")
                stream_name = data[read_offset+8:read_offset+8+index].decode()
                #print(stream_name)
                name_size = index + (4 - (index % 4))
                read_offset += 8 + name_size
                if(stream_name == '#US'):
                    USoffset = metadataFO + offset + 1          # +1 is for skipping 1st byte of #US
                    str_offset = USoffset
                    while str_offset < USoffset + size:
                        if data[str_offset] & 0xC0 == 0xC0:
                            str_size = ((data[str_offset+1] << 8) + (data[str_offset+2] << 8)) + data[str_offset+3]
                            str_offset += 4
                        elif data[str_offset] & 0x80 == 0x80:
                            str_size = (data[str_offset] - 0x80) * 0x100 + data[str_offset + 1]
                            str_offset += 2
                        else:
                            str_size = data[str_offset]
                            str_offset += 1
                        string = data[str_offset:str_offset + str_size - 2][::2]
                        #print(string)

                        encrypted_data.append(string)

                        str_offset +=  str_size
                    break
            #print(hex(offset))

            # Decrypted key
            decrypted_key = base64.b64decode(encrypted_data[7].decode())
            #print(decrypted_key)
            
            salt = b'DcRatByqwqdanchun'
            aes_key = pbkdf2_hmac("sha1", decrypted_key, salt, 50000, 32)
            
            for i, names in Settings.items():
                try:
                    decrypt = base64.b64decode(encrypted_data[i])
                    iv = decrypt[32:48]
                    decrypted_data = unpad(aes.cbc.decrypt(aes_key, iv, decrypt[48:]))
                    print("{} : {}".format(names, decrypted_data.decode()))
                except:
                    pass
    except Exception as e:
        print(e)
        pass
