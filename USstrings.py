import struct
import pefile
import sys
import base64
import hashlib
import os
from binascii import hexlify
from backports.pbkdf2 import pbkdf2_hmac
from malduck import aes, unpad

def get_US_strings(FILE_PATH):
    try:
        encrypted_data = []
        data = open(FILE_PATH, 'rb').read()
        peobject = pefile.PE(data = data)
        entry_point = peobject.OPTIONAL_HEADER.AddressOfEntryPoint

        isDotnet = peobject.OPTIONAL_HEADER.DATA_DIRECTORY[14]
        if(isDotnet.Size != 0):
            dotnet_directoryVA = isDotnet.VirtualAddress
            dotnet_directoryFO = peobject.get_offset_from_rva(dotnet_directoryVA)
            metadata_rva = struct.unpack("<I", data[dotnet_directoryFO + 8 : dotnet_directoryFO+12])[0]
            metadata_size = struct.unpack("<I", data[dotnet_directoryFO + 12 : dotnet_directoryFO + 16])[0]

            metadataFO = peobject.get_offset_from_rva(metadata_rva)
            #print(data[metadataFO : metadataFO + 4])

            no_of_stream = struct.unpack("<H", data[metadataFO + 30 : metadataFO + 32])[0]

            read_offset = metadataFO + 32
            for i in range(0, no_of_stream):
                offset, size = struct.unpack_from("<II", data[read_offset:read_offset+8])
                index = data[read_offset+8:].find(b"\x00")
                stream_name = data[read_offset+8:read_offset+8+index].decode()
                #print(stream_name)
                name_size = index + (4 - (index % 4))
                read_offset += 8 + name_size
                if(stream_name == '#US'):
                    USoffset = metadataFO + offset + 1          # +1 is for skipping 1st byte of #US
                    str_offset = USoffset
                    while str_offset < USoffset + size:
                        if data[str_offset] & 0xC0 == 0xC0:
                            str_size = ((data[str_offset+1] << 8) + (data[str_offset+2] << 8)) + data[str_offset+3]
                            str_offset += 4
                        elif data[str_offset] & 0x80 == 0x80:
                            str_size = (data[str_offset] - 0x80) * 0x100 + data[str_offset + 1]
                            str_offset += 2
                        else:
                            str_size = data[str_offset]
                            str_offset += 1
                        string = data[str_offset:str_offset + str_size - 2][::2]
                        #print(string)

                        encrypted_data.append(string)

                        str_offset +=  str_size
                    break
        return encrypted_data
    except Exception as e:
        print(e)
        pass
